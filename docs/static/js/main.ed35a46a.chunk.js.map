{"version":3,"sources":["utils.ts","Game/Cell.tsx","Game/Grid.tsx","Game/Game.tsx","App.tsx","index.tsx"],"names":["parseCoord","coord","coordArray","split","x","parseInt","y","getStartEnd","numA","numB","Math","min","max","calculateValidLine","start","end","startCoord","endCoord","yDiff","xDiff","line","isValidHorizontalLine","coords","startX","endX","push","calculateHorizontalLine","isValidVerticalLine","startY","endY","calculateVerticalLine","abs","isValidDiagonalLine","len","xGrows","yGrows","i","calculateDiagonalLine","length","reverse","HIGHLIGHTED_COLOR","Root","styled","div","props","highlighted","selected","Cell","children","onMouseDown","onMouseMove","onMouseUp","data-coord","React","memo","columns","getCoordFromDataset","event","target","HTMLElement","dataset","Grid","grid","highlightedCells","onWordSelected","useState","isMouseDown","setIsMouseDown","setStartCoord","Set","selectedCells","setSelectedCells","prevCoord","useRef","useEffect","handleMouseUp","document","addEventListener","removeEventListener","handleMouseDown","useCallback","handleMouseMove","current","Array","from","data-testid","map","arr","letter","has","Paragraph","p","Spacer","Game","game","onGameFinished","foundCoords","setFoundCoords","wordLocations","foundWordsCount","reset","Object","keys","word_locations","word","source_language","target_language","character_grid","includes","join","Title","h1","App","games","gameIndex","setGameIndex","currentGame","aria-label","role","inputs","require","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.ed35a46a.chunk.js","sourcesContent":["import { Coordinate } from \"./types\";\n\nconst parseCoord = (coord: string): Coordinate => {\n  const coordArray = coord.split(\",\");\n  return {\n    x: parseInt(coordArray[0], 10),\n    y: parseInt(coordArray[1], 10),\n  };\n};\n\nconst isValidHorizontalLine = (xDiff: number, yDiff: number) => !yDiff && xDiff;\nconst isValidVerticalLine = (xDiff: number, yDiff: number) => !xDiff && yDiff;\nconst isValidDiagonalLine = (xDiff: number, yDiff: number) =>\n  Math.abs(yDiff) === Math.abs(xDiff);\n\nconst getStartEnd = (numA: number, numB: number) => {\n  return [Math.min(numA, numB), Math.max(numA, numB)];\n};\n\nconst calculateHorizontalLine = (\n  startCoord: Coordinate,\n  endCoord: Coordinate\n): string[] => {\n  const coords = [];\n  const [startX, endX] = getStartEnd(startCoord.x, endCoord.x);\n  for (let x = startX; x <= endX; x++) {\n    coords.push(`${x},${startCoord.y}`);\n  }\n  return coords;\n};\n\nconst calculateVerticalLine = (\n  startCoord: Coordinate,\n  endCoord: Coordinate\n): string[] => {\n  const coords = [];\n  const [startY, endY] = getStartEnd(startCoord.y, endCoord.y);\n  for (let y = startY; y <= endY; y++) {\n    coords.push(`${startCoord.x},${y}`);\n  }\n  return coords;\n};\n\nconst calculateDiagonalLine = (\n  startCoord: Coordinate,\n  endCoord: Coordinate\n): string[] => {\n  const coords = [];\n  const len = Math.abs(startCoord.x - endCoord.x);\n  const xGrows = startCoord.x < endCoord.x;\n  const yGrows = startCoord.y < endCoord.y;\n\n  for (let i = 0; i <= len; i++) {\n    const x = xGrows ? startCoord.x + i : startCoord.x - i;\n    const y = yGrows ? startCoord.y + i : startCoord.y - i;\n    coords.push(`${x},${y}`);\n  }\n  return coords;\n};\n\nexport const calculateValidLine = (start: string, end: string): string[] => {\n  const startCoord = parseCoord(start);\n  const endCoord = parseCoord(end);\n\n  const yDiff = startCoord.y - endCoord.y;\n  const xDiff = startCoord.x - endCoord.x;\n\n  let line: string[] = [];\n\n  if (isValidHorizontalLine(xDiff, yDiff)) {\n    line = calculateHorizontalLine(startCoord, endCoord);\n  }\n\n  if (isValidVerticalLine(xDiff, yDiff)) {\n    line = calculateVerticalLine(startCoord, endCoord);\n  }\n\n  if (isValidDiagonalLine(xDiff, yDiff)) {\n    line = calculateDiagonalLine(startCoord, endCoord);\n  }\n\n  if (!line.length) {\n    return line;\n  }\n\n  return start !== line[0] ? line.reverse() : line;\n};\n","import React, { ReactNode } from \"react\";\nimport styled from \"styled-components\";\n\ninterface StyledCellProps {\n  highlighted: boolean;\n  selected: boolean;\n}\n\nexport const HOVER_COLOR = \"lemonchiffon\";\nexport const HIGHLIGHTED_COLOR = \"#ffef00\";\n\nconst Root = styled.div<StyledCellProps>`\n  text-align: center;\n  padding: 8px;\n  font-size: 24px;\n  font-weight: bold;\n  border-bottom: 1px solid black;\n  border-right: 1px solid black;\n  user-select: none;\n  cursor: pointer;\n  background-color: ${(props) =>\n    props.highlighted || props.selected ? HIGHLIGHTED_COLOR : \"white\"};\n\n  &:hover {\n    background-color: ${(props) =>\n      props.selected ? HIGHLIGHTED_COLOR : HOVER_COLOR};\n  }\n`;\n\nexport interface CellProps {\n  children: ReactNode;\n  coord: string;\n  highlighted?: boolean;\n  selected?: boolean;\n  onMouseDown?: (event: React.MouseEvent<HTMLElement>) => void;\n  onMouseMove?: (event: React.MouseEvent<HTMLElement>) => void;\n  onMouseUp?: (event: React.MouseEvent<HTMLElement>) => void;\n}\n\nconst Cell = ({\n  children,\n  coord,\n  highlighted = false,\n  selected = false,\n  onMouseDown = () => {},\n  onMouseMove = () => {},\n  onMouseUp = () => {},\n}: CellProps) => {\n  return (\n    <Root\n      data-coord={coord}\n      highlighted={highlighted}\n      selected={selected}\n      onMouseDown={onMouseDown}\n      onMouseMove={onMouseMove}\n      onMouseUp={onMouseUp}\n    >\n      {children}\n    </Root>\n  );\n};\n\nexport default React.memo(Cell);\n","import React, { useCallback, useEffect, useRef, useState } from \"react\";\nimport styled from \"styled-components\";\n\nimport { CharacterGrid } from \"../types\";\nimport { calculateValidLine } from \"../utils\";\n\nimport Cell from \"./Cell\";\n\ninterface StyledGridProps {\n  columns?: number;\n}\n\nconst Root = styled.div<StyledGridProps>`\n  display: grid;\n  grid-template-columns: repeat(${(props) => props.columns || 1}, 50px);\n  border-top: 1px solid black;\n  border-left: 1px solid black;\n`;\n\nexport interface GridProps {\n  grid: CharacterGrid;\n  highlightedCells: Set<string>;\n  onWordSelected?: (coords: string[]) => boolean;\n}\n\nconst getCoordFromDataset = (event: React.MouseEvent<HTMLElement>): string => {\n  if (event.target instanceof HTMLElement) {\n    return event.target.dataset[\"coord\"] || \"\";\n  }\n  return \"\";\n};\n\nconst Grid = ({\n  grid,\n  highlightedCells,\n  onWordSelected = () => false,\n}: GridProps) => {\n  const [isMouseDown, setIsMouseDown] = useState(false);\n  const [startCoord, setStartCoord] = useState(\"\");\n  const [selectedCells, setSelectedCells] = useState(new Set<string>());\n  const prevCoord = useRef(\"\");\n\n  useEffect(() => {\n    const handleMouseUp = () => {\n      setIsMouseDown(false);\n    };\n\n    // quit \"selection mode\" when mouse up happens outside of the grid\n    document.addEventListener(\"mouseup\", handleMouseUp);\n    return () => document.removeEventListener(\"mouseup\", handleMouseUp);\n  }, []);\n\n  useEffect(() => {\n    setSelectedCells(new Set<string>());\n  }, [grid]);\n\n  const handleMouseDown = useCallback(\n    (event: React.MouseEvent<HTMLElement>) => {\n      setIsMouseDown(true);\n      setStartCoord(getCoordFromDataset(event));\n    },\n    []\n  );\n\n  const handleMouseMove = (event: React.MouseEvent<HTMLElement>) => {\n    if (isMouseDown) {\n      const coord = getCoordFromDataset(event);\n\n      // since mouse move happens many times for the same cell, instead of\n      // throttling the event handler we use a ref for the previous coord to\n      // prevent calculating the same line multiple times\n      if (startCoord !== coord && coord !== prevCoord.current) {\n        const line = calculateValidLine(startCoord, coord);\n        setSelectedCells(new Set(line));\n        prevCoord.current = coord;\n      }\n    }\n  };\n\n  const handleMouseUp = (event: React.MouseEvent<HTMLElement>) => {\n    setIsMouseDown(false);\n\n    // onWordSelected callback will return true if the selected line is a valid word\n    if (!onWordSelected(Array.from(selectedCells))) {\n      setSelectedCells(new Set<string>());\n    }\n  };\n\n  return (\n    <Root columns={grid.length} data-testid=\"grid\">\n      {grid.map((arr: string[], y: number) =>\n        arr.map((letter: string, x: number) => {\n          const coord = `${x},${y}`;\n          return (\n            <Cell\n              key={coord}\n              coord={coord}\n              highlighted={highlightedCells.has(coord)}\n              selected={selectedCells.has(coord)}\n              onMouseDown={handleMouseDown}\n              onMouseMove={handleMouseMove}\n              onMouseUp={handleMouseUp}\n            >\n              {letter}\n            </Cell>\n          );\n        })\n      )}\n    </Root>\n  );\n};\n\nexport default Grid;\n","import React, { useCallback, useEffect, useRef, useState } from \"react\";\nimport styled from \"styled-components\";\n\nimport { InputType } from \"../types\";\nimport Grid from \"./Grid\";\n\nconst Paragraph = styled.p`\n  font-size: 20px;\n  margin: 5px 0;\n  text-align: center;\n`;\n\nconst Spacer = styled.div`\n  margin-bottom: 20px;\n`;\n\nexport interface GameProps {\n  game: InputType;\n  onGameFinished?: () => void;\n}\n\nconst Game = ({ game, onGameFinished = () => {} }: GameProps) => {\n  const [foundCoords, setFoundCoords] = useState(new Set<string>());\n  const wordLocations = useRef([] as string[]);\n  const foundWordsCount = useRef(0);\n\n  const reset = useCallback(() => {\n    setFoundCoords(new Set<string>());\n    wordLocations.current = Object.keys(game.word_locations);\n    foundWordsCount.current = 0;\n  }, [game]);\n\n  useEffect(() => {\n    if (game) {\n      reset();\n    }\n  }, [game, reset]);\n\n  const handleWordSelected = (coords: string[]): boolean => {\n    if (wordLocations.current.includes(coords.join(\",\"))) {\n      foundWordsCount.current += 1;\n\n      if (foundWordsCount.current === wordLocations.current.length) {\n        onGameFinished();\n      } else {\n        setFoundCoords(new Set([...Array.from(foundCoords), ...coords]));\n      }\n\n      return true;\n    }\n\n    return false;\n  };\n\n  return (\n    <>\n      <Spacer>\n        <Paragraph>\n          Search word: <strong>{game.word}</strong>\n        </Paragraph>\n        <Paragraph>\n          Source language: <strong>{game.source_language}</strong>\n        </Paragraph>\n        <Paragraph>\n          Target language: <strong>{game.target_language}</strong>\n        </Paragraph>\n        <Paragraph>\n          Words to find:{\" \"}\n          <strong>\n            {foundWordsCount.current}/{wordLocations.current.length}\n          </strong>\n        </Paragraph>\n      </Spacer>\n      <Grid\n        grid={game.character_grid}\n        highlightedCells={foundCoords}\n        onWordSelected={handleWordSelected}\n      />\n    </>\n  );\n};\n\nexport default Game;\n","import React, { useState } from \"react\";\nimport styled from \"styled-components\";\n\nimport { InputType } from \"./types\";\nimport Game from \"./Game\";\n\nconst Root = styled.div`\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  width: 800px;\n  margin: 0 auto;\n`;\n\nconst Title = styled.h1`\n  font-family: \"Unica One\", cursive;\n  font-size: 40px;\n\n  span {\n    font-size: 34px;\n  }\n`;\n\nexport interface AppProps {\n  games?: InputType[];\n}\n\nfunction App({ games = [] }: AppProps) {\n  const [gameIndex, setGameIndex] = useState(0);\n\n  const handleGameFinished = () => {\n    setGameIndex(gameIndex + 1);\n  };\n\n  const currentGame = games[gameIndex];\n\n  return (\n    <Root>\n      <Title>\n        Word Search{\" \"}\n        <span aria-label=\"Magnifying glass\" role=\"img\">\n          🔍\n        </span>\n      </Title>\n      {currentGame ? (\n        <Game game={currentGame} onGameFinished={handleGameFinished} />\n      ) : (\n        <h2>There are no more games!</h2>\n      )}\n    </Root>\n  );\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\n\nimport { InputType } from \"./types\";\nimport App from \"./App\";\n\nconst inputs: InputType[] = require(\"./inputs.json\");\n\nReactDOM.render(\n  <React.StrictMode>\n    <App games={inputs} />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}